> :notes: 代码先不急；目前是熟悉整个方向的全局

:negative_squared_cross_mark:了解这个方向的全流程

+ **firecraker**的源码
+ 大体执行流程：容器的与虚拟机（两个版本的）
+ 搜索目前企业是否存在部署方案

:negative_squared_cross_mark:相关知识点

+ 容器(构建部署)
+ 虚拟机(底层原理，布置)

:negative_squared_cross_mark:设计

:warning: `snapshot`到底存了什么东西，到底恢复到什么状态

+ 工作页面设别

> (1) 目前的方法是通过user-fault或者通过线程扫描标志位(对于预取页面来说user-fault是无法检测到的)。同时其加载时是按照访问顺序来的(本文设置了工作组的方式)。
>
> + 是否可以采用迭代的方式记录工作组（系统资源丰富时，目前也只是做了工作集分组，动静态结合）
> + 是否可以采用内存分组的形式记录热页面，给与特殊处理（巨页）:gem:  (虚拟机申请的是不是一块大内存？)
> + 复用其0页的识别
> + 异步映射/预取，当对应的内存没有被映射时，特殊处理

+ 进程快速启动

>  目前针对C语言的代码，启动入口直接设置为main。其他的库状态预保留，设计一个特殊的`do_execve`函数。 ./hello  直接跳转至main位置。因为本来相关状态便存在snapshot中。

+ 模板VM

> 已有的时模板`func image`, 此处为snapnot的模板，感觉创新有点弱。

+ 巨页共用

> 反正都是虚拟机：同类型的共用虚拟机

:negative_squared_cross_mark: **基于rust-vmm开发自己的虚拟机**

